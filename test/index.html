<html>

<head>
    <title>诗云块编辑器</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="referrer" content="unsafe-url">
</head>

<body>
    <meta charset='utf-8'>
    <p>行高、字间距、排序方式（正排、倒排)、文字的起始位置</p>
    <h3>块的编辑点</h3>
    <ol>
        <li>编辑点即块的操作点，对于文本则有文本的编辑区域，在文本编辑区域中有光标，通过光标来键入文字，对于solid块如图像，则是表示对图像的选中，支持删除</li>
        <li>一个块可以有多个编辑点，也可以没有，光标是在编辑点左右上下来回跳动。</li>
    </ol>
    <h3>块的排版结构</h3>
    <ol>
        <li>row 里面有多个col，每个col有多个row</li>
        <li>row-block(table)-row-col <strong>简单表格块</strong>的排版</li>
        <li>row-block(list)-row(childs) <strong>list</strong>有子元素的块排版</li>
    </ol>
    <h3>文字块的特殊显示</h3>
    <ul>
        <li>对于查找的元素，则是高亮（类似于浏览器这样的）</li>
        <li>对于文字块，检查错别字（文字下面有红色的波浪线）</li>
    </ul>
    <h3>块的关注点</h3>
    <p>&lt;aside&gt;
        💡 需要理解设计的这些所表现的特性</p>
    <p>&lt;/aside&gt;</p>
    <ol>
        <li>块编辑的是块里面的编辑点(Element Appear Anchor)</li>
        <li>块的编辑点是当前块，用户所关注的内容焦点（一个块可以有多个不同的编辑点）</li>
        <li>光标会在块里面的编辑点上下左右移动</li>
        <li>选区选中的是块里面的编辑点，块有编辑点才视为有内容的块。</li>
        <li>对于简单表格、数据表格而言，单元格就是一个呈现不同内容的块容器（单元格是不能删除的，会保留下用户最基本的输入，至少要有这样的感觉）</li>
        <li>块会包含子块，该块可以仅仅是一个容器也可以有自身的内容块（例如list块），块到子块由blockKeys来决循环顺序，块内部的编辑点由appearAnchors来决定</li>
    </ol>
    <h3>光标的定位</h3>
    <p><code>文字区域内的定位</code></p>
    <p>名词： 可编辑的文本区域rect(文字容器，非行内元素)，编辑区域(就是文字所在的区域，行内元素）</p>
    <p>结构:文字容器包含多个行内文本</p>
    <p>计算考虑的因素</p>
    <ol>
        <li>位置位于文字容器外的计算，如果位于文字容器外，则取文字容器四周某个方位邻近计算。</li>
        <li>编辑区域不一定是以文字容器开头的，编辑区域前面还有其它的行内元素，首个文字行宽应是容器宽度-编辑区域的宽度。余下是容器的宽度。（注意容器可能有border,padding)</li>
        <li>文字容器不一定就大于编辑区域（实际上文字的容器是由编辑区域增大的，在某些情况下会出现 文字容器视野范围小于编辑区域范围的情况），这时需要将编辑区域的大小赋给容器大大。</li>
        <li>文字容器的高度不一定是文字行高(lineHeight)的倍数。对于1计算邻近时，需要取容器提供的行高陪数来取而非容器的高度</li>
        <li>文字之间的距离除了考虑文字本身大小之外，还需要考虑文字字间距的问题。</li>
        <li>文字换行符，不同的操作系统换行符还不太一样。</li>
        <li>中英文相邻，间距会越大一些，这样显的排版好看一些（这里在实际计算时要考虑）</li>
        <li>文字的排版方向、有正排还有倒排。</li>
        <li>另外文字区域是有可能处于<strong>旋转情况</strong>的。这里在计算是可能需要将坐标进行2d变换，在计算。</li>
        <li>有部分块可能会被隐藏不显示，那么假设突然隐藏了，那么此时恰好光标就在隐藏的元素上，这里可能需要处理一下</li>
        <li>部分块会被隐藏，那么光标定位时会对block进行搜索，需要排除那些不显示的block（目前是通过blockKeys来管理的，例如list块隐藏时，其不在有subChilds）</li>
    </ol>
    <p><code>块里面的编辑点来定位</code></p>
    <p>比如一个容器块，已知坐标，计算点在容器内的那个块什么位置上。</p>
    <ol>
        <li>
            <p>计算点在那个块上</p>
            <p>找到所有含有编辑点的的块。</p>
            <p>优先查找水平、垂直均为0的元素</p>
            <p>优先查找垂直为0的，在查找水平最小的。</p>
            <p>优先查找垂真最小的一批元素，然后从一批元素中挑选水平最小的</p>
        </li>
        <li>
            <p>计算点在块的那个位子上（编辑点）</p>
            <p>查找优先过程如计算1</p>
        </li>
    </ol>
    <h3>光标的移动</h3>
    <p><code>水平移动</code></p>
    <ol>
        <li>相邻的两个行内元素，需要考虑是否挨的很近，如果很近右移，则是从前一个文字元素末尾，移到别一个元素的开始第二位。左移则是从一个字文元素的开头移到另一个文字元素的末尾倒数第二位。</li>
        <li>在块之间的移动可能情况有
            <ol>
                <li>block-row-pre-row.find（content) 两个相邻的row移动（没有<strong>编辑点的块</strong>就继续找）</li>
                <li>block-row-col.findLast(content) 行前没有了，找到所属的col，然后在通过col找前面的**（没有就继续找）**</li>
                <li>block-row-row.(self).findLast(content)
                    行前面没有了，但有父行，如果父行有content，则移到父行content的末尾。以list组件为例。<strong>list组件</strong>是处于父行与list组件子行中间的<strong>夹着</strong>。
                </li>
            </ol>
        </li>
    </ol>
    <p><code>垂直移动</code></p>
    <ol>
        <li>文字段落内部，上下移动</li>
        <li>块之间的上下移动的可能情况有
            <ol>
                <li>block→block,上下移动前需要计算光标水平上的位置（文本光标和实体光标计算方式有区别）</li>
                <li>block→block[content]-childs
                    上下移动，由子元素移到父元素的本身block，例如list组件的上下移动，<code>注意</code>从子组件移到父组件本身是，其top计算为父组件的范围减去父组件所在行的计算</li>
            </ol>
        </li>
    </ol>
    <h3>光标的呈现</h3>
    <ol>
        <li>
            <p>文本光标</p>
            <p>如果文本为空，则需要呈现占位符</p>
        </li>
        <li>
            <p>元素光标(solid)</p>
            <p>对元素加一个淡蓝色的选区，然后右侧光标闪动</p>
        </li>
    </ol>
    <h3>光标输入</h3>
    <p><code>输入的情况</code></p>
    <ol>
        <li>正常的输入，然后输入enter换行
            <ol>
                <li>如果enter在文字最前面触发时，则在当前行的block前面插入一个空白的行block,而不是文字内容换行</li>
                <li>如果enter没触发在末尾
                    <ol>
                        <li>对于正常文本则是产生一个换行的输入而已</li>
                        <li>对于todo，则是换行创建一个新的block</li>
                        <li>对于仅输入特定字符的块（没有换行的），则是输入无效，例如输入数字</li>
                    </ol>
                </li>
                <li>如果enter触发在末尾
                    <ol>
                        <li>对于正常文本，则是创建一个新的输入文本块</li>
                        <li>对于todo，则是创建一个新的没有输入的todo模块</li>
                        <li>对于输入特字的字符的块，则是输入无效</li>
                    </ol>
                </li>
            </ol>
        </li>
        <li>正常的输入，输入特定的字符如\，则弹出下拉block选择器，继续输入，则查换，在继续输入，没查找到，则关闭block选择器
            <ol>
                <li>下拉选择要创建的block</li>
                <li>下拉选择要转换的block</li>
                <li>下拉选择要触发执行的命令</li>
            </ol>
        </li>
        <li>正常的输入，输入@符，则弹出上下文选择器，继续输入，则查找，在继续输入，没有查到，关闭弹窗</li>
        <li>如果为开头[]，则表示输入待办</li>
        <li>如果输入为1. 则表示是输入list列表，该列表会考虑前面的列表，输入..，输入*.等</li>
        <li>如果开头输入——，则会自动创建一个下划线</li>
        <li>如果输入特定的定符！=、-》等则会自动转换成特定的字符</li>
        <li>如果开头输入##加空格，则创建一个标题block</li>
        <li>如果输入<code>sss</code>，则表示创建一个code块</li>
        <li>如果输入[[,则会弹出一个下拉选项，选择要链接的页面</li>
        <li>如果输入((，则会行内链接</li>
    </ol>
    <p><code>输入时的处理需要考虑的细节</code></p>
    <ol>
        <li>输入粗体，斜体后会导致最后一行没办切换输入格式</li>
        <li>比如文字前面本身就有一个* 然后隔了很远，在输入* 是否触发转成一个斜体
            <ol>
                <li>如果没有连续输入，重新输入焦点，那么不会触发转成斜体</li>
                <li>如果是连续输入，那么隔了老远被触发，其实是有点怪怪的</li>
            </ol>
        </li>
        <li>在一行文字中，在文字的开头输入[]，需要触发将当前的文字转成待办block</li>
    </ol>
    <p><code>输入回退delete</code></p>
    <ol>
        <li>
            <p>回退的元素处于两个相邻的line块</p>
            <ol>
                <li>如果后面的line块是空的，则该line块会自动删除</li>
                <li>如果后面的line块是solid，则该solid块会自动删除</li>
                <li>如果后面的line块为非空的，则该line块仍然保留</li>
            </ol>
        </li>
        <li>
            <p>回退的元素处于当前块的开头且处于当前行的最前面时</p>
            <ul>
                <li>如果是todo，list块，则需要进一步删除，且当前的块变成空白的文本块</li>
                <li>如果当前的块是空的，则当前块行是删除的</li>
                <li>如果当前的块有文本，则会与上面的块进行文本式的合并(如果当前行有多列，则不合并，仅有一列才合并</li>
                <li>如果是输入特定字符的块，回退则不删除当前块合并内容，光标会移到上一行</li>
            </ul>
            <p><code>触发的先决条件</code></p>
            <p>在数据表格单元格中，输入/、@、[[,((时不能触发。</p>
            <p>在代码编辑模块、数据表格值block时，输入特殊的字符！=、-》将不会替换</p>
            <p>用户配置了不会自动转换特殊字符的功能</p>
            <p><code>光标触发的详细情况</code></p>
            <p><a href="https://www.notion.so/Learn-the-shortcuts-66e28cec810548c3a4061513126766b0">Learn the
                    shortcuts</a></p>
            <p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23101c9a-a8f8-4bc6-a17e-13692b063b5c/Untitled.png"
                    alt="Untitled"></p>
            <p><code>光标输入考虑的细节</code></p>
            <ol>
                <li>如果是line code块，那么在点在code块文字尾部时，需要主动创一个新的文本块，否则会导致一直输入在linecode块中。这里只需要考虑code块后面没有其它块，那么只有输入就创建新的文本块
                </li>
                <li>通过markdown语法创建的粗体块、斜体块，用户点在行内块的末尾，一直输入都会输入到该块，导致出现很长的粗体块，也许用户只是想在粗体块后面继续输入文本块呢？？。</li>
                <li>通过markdown语法输入粗体、斜体，只有在块的开头输入才起作用，至于对于notion和wolai是这样的，<code>这个主要是防止干扰输入</code></li>
            </ol>
        </li>
    </ol>
    <h3>选区</h3>
    <p>主要是选中页面中块范围外围el区域（不是编辑点）</p>
    <p><code>选区的触发方式</code></p>
    <ol>
        <li>光标按住不松，选中文字，如果跨block了（不在同一行），则是批量选中，注意考虑选中<strong>空的文本块</strong></li>
        <li>不在当前块的范围内，开始选择，这里需要绘制一个选择的矩形区域，与矩形区域相交的block会被批量选中</li>
        <li>点击时同时按住shift，则会以当前的activeAnchor做为选区的起点，而点击所在的anchor做为选区的结束点。</li>
        <li>是否考虑支持<strong>点选</strong>，如按住ctrl+然后点击block，这对于表格这样的block选择多个单元格挺有效的。</li>
    </ol>
    <p><code>通过矩形区域计算被选中的block</code></p>
    <p>通过起点和终点，来确认当前矩形区域所在的行block,然后通过行block来进行查询，确实区域是否与当前的block有相交。</p>
    <p><code>对选区的操作</code></p>
    <ol>
        <li>通过打开texttool对选区进行操作
            <ol>
                <li>切换block(行block）</li>
                <li>对block进行加粗、斜体等操作
                    <ol>
                        <li>该操作对单独的块</li>
                    </ol>
                </li>
            </ol>
        </li>
        <li>按住delete键删除</li>
    </ol>

</body>

</html>